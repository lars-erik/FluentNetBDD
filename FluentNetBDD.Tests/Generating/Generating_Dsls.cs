using FluentNetBDD.Generation;
using FluentNetBDD.Generators;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace FluentNetBDD.Tests.Generating;

public class Generating_Dsls
{
    private const string GenerateAgileNamedUserDslSource =
        """
        using FluentNetBDD.Dsl;
        using FluentNetBDD.Generation;
        using FluentNetBDD.Tests.Dsl.UserFeatures;
        
        namespace FluentNetBDD.Tests.Generating;
        
        [GenerateDsl(
            "AgileNamedUser",
            givenTypes: [typeof(IUserWithName), typeof(IUserWithAgility)],
            whenTypes: [typeof(IUserGreetingAction), typeof(IUserAgilityActions)],
            thenTypes: [typeof(IUserGreetingVerification), typeof(IUserAgilityVerification)]
        )]
        
        public class JustSomethingToHangOnTo 
        {
        }
        """;

    [Test]
    public void Creates_Builders_For_Actors_And_Subjunctions()
    {
        var generatedSource = Generate(GenerateAgileNamedUserDslSource, true);

        Console.WriteLine(generatedSource);

        Assert.That
        (
            generatedSource,
            Is.EqualTo
            (
            """
            // <auto-generated/>
            
            using System;
            using FluentNetBDD.Dsl;
            using FluentNetBDD.Tests.Dsl.UserFeatures;
            using System.Runtime.CompilerServices;
            using FluentNetBDD.Dsl.Builders;
            
            namespace FluentNetBDD.Tests.Generating.Generated;
            
            #nullable enable
            
            public interface IAgileNamedUserGivenUserDriver : IUserWithName, IUserWithAgility {}
            public interface IAgileNamedUserGivenDriver
            {
                IAgileNamedUserGivenUserDriver User { get; }
            }
            
            public interface IAgileNamedUserWhenUserDriver : IUserGreetingAction, IUserAgilityActions {}
            public interface IAgileNamedUserWhenDriver
            {
                IAgileNamedUserWhenUserDriver User { get; }
            }
            
            public interface IAgileNamedUserThenUserDriver : IUserGreetingVerification, IUserAgilityVerification {}
            public interface IAgileNamedUserThenDriver
            {
                IAgileNamedUserThenUserDriver User { get; }
            }
            
            public class AgileNamedUserGivenUserBuilder
            {
                private readonly IAgileNamedUserGivenUserDriver driver;
                
                public AgileNamedUserGivenUserBuilder And => this;
                
                public AgileNamedUserGivenUserBuilder(IAgileNamedUserGivenUserDriver driver)
                {
                    this.driver = driver;
                }
                
                public AgileNamedUserGivenUserBuilder WithName(String name)
                {
                    actions.Add(async () => await Task.Run(() => driver.WithName(name)));
                    return this;
                }
            
                public AgileNamedUserGivenUserBuilder WithAgility(Int32 agility)
                {
                    actions.Add(async () => await Task.Run(() => driver.WithAgility(agility)));
                    return this;
                }
            
            
                // THIS REALLY HAS TO GO INTO A BASE CLASS
                private Task? task = null;
                private readonly List<Func<Task>> actions = new();
                
                protected Task ToTask() => task ??= actions.Aggregate
                (
                    Task.CompletedTask,
                    (prev, next) => prev.ContinueWith(_ => next()).Unwrap()
                );
                
                public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => ToTask().ConfigureAwait(continueOnCapturedContext);
                
                public TaskAwaiter GetAwaiter() => ToTask().GetAwaiter();
                
                public static implicit operator Task(AgileNamedUserGivenUserBuilder builder) => builder.ToTask();
            
            }
            
            public class AgileNamedUserGivenBuilder
            {
                public AgileNamedUserGivenUserBuilder User { get; }
            
                public AgileNamedUserGivenBuilder
                (
                    IAgileNamedUserGivenDriver driver
                )
                {
                    this.User = new AgileNamedUserGivenUserBuilder(driver.User);
                }
            }
            
            public class AgileNamedUserWhenUserBuilder
            {
                private readonly IAgileNamedUserWhenUserDriver driver;
                
                public AgileNamedUserWhenUserBuilder And => this;
                
                public AgileNamedUserWhenUserBuilder(IAgileNamedUserWhenUserDriver driver)
                {
                    this.driver = driver;
                }
                
                public AgileNamedUserWhenUserBuilder IsGreeted()
                {
                    actions.Add(async () => await Task.Run(() => driver.IsGreeted()));
                    return this;
                }
            
                public AgileNamedUserWhenUserBuilder Jumps()
                {
                    actions.Add(async () => await Task.Run(() => driver.Jumps()));
                    return this;
                }
            
                    public AgileNamedUserWhenUserBuilder Runs(UInt32 meters)
                {
                    actions.Add(async () => await Task.Run(() => driver.Runs(meters)));
                    return this;
                }
            
            
                // THIS REALLY HAS TO GO INTO A BASE CLASS
                private Task? task = null;
                private readonly List<Func<Task>> actions = new();
                
                protected Task ToTask() => task ??= actions.Aggregate
                (
                    Task.CompletedTask,
                    (prev, next) => prev.ContinueWith(_ => next()).Unwrap()
                );
                
                public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => ToTask().ConfigureAwait(continueOnCapturedContext);
                
                public TaskAwaiter GetAwaiter() => ToTask().GetAwaiter();
                
                public static implicit operator Task(AgileNamedUserWhenUserBuilder builder) => builder.ToTask();
            
            }
            
            public class AgileNamedUserWhenBuilder
            {
                public AgileNamedUserWhenUserBuilder User { get; }
            
                public AgileNamedUserWhenBuilder
                (
                    IAgileNamedUserWhenDriver driver
                )
                {
                    this.User = new AgileNamedUserWhenUserBuilder(driver.User);
                }
            }
            
            public class AgileNamedUserThenUserBuilder
            {
                private readonly IAgileNamedUserThenUserDriver driver;
                
                public AgileNamedUserThenUserBuilder And => this;
                
                public AgileNamedUserThenUserBuilder(IAgileNamedUserThenUserDriver driver)
                {
                    this.driver = driver;
                }
                
                public AgileNamedUserThenUserBuilder Hears(String greeting)
                {
                    actions.Add(async () => await Task.Run(() => driver.Hears(greeting)));
                    return this;
                }
            
                public AgileNamedUserThenUserBuilder Jumped(UInt32 meters)
                {
                    actions.Add(async () => await Task.Run(() => driver.Jumped(meters)));
                    return this;
                }
            
            
                // THIS REALLY HAS TO GO INTO A BASE CLASS
                private Task? task = null;
                private readonly List<Func<Task>> actions = new();
                
                protected Task ToTask() => task ??= actions.Aggregate
                (
                    Task.CompletedTask,
                    (prev, next) => prev.ContinueWith(_ => next()).Unwrap()
                );
                
                public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) => ToTask().ConfigureAwait(continueOnCapturedContext);
                
                public TaskAwaiter GetAwaiter() => ToTask().GetAwaiter();
                
                public static implicit operator Task(AgileNamedUserThenUserBuilder builder) => builder.ToTask();
            
            }
            
            public class AgileNamedUserThenBuilder
            {
                public AgileNamedUserThenUserBuilder User { get; }
            
                public AgileNamedUserThenBuilder
                (
                    IAgileNamedUserThenDriver driver
                )
                {
                    this.User = new AgileNamedUserThenUserBuilder(driver.User);
                }
            }
            
            public partial class AgileNamedUserDsl : Dsl<AgileNamedUserGivenBuilder, AgileNamedUserWhenBuilder, AgileNamedUserThenBuilder>
            {
                public AgileNamedUserDsl(IServiceProvider provider)
                {
                    var givenDriver = DslTermProxyBuilder.Create<IAgileNamedUserGivenDriver>(nameof(Given), provider);
                    var whenDriver = DslTermProxyBuilder.Create<IAgileNamedUserWhenDriver>(nameof(When), provider);
                    var thenDriver = DslTermProxyBuilder.Create<IAgileNamedUserThenDriver>(nameof(Then), provider);
            
                    Given = new AgileNamedUserGivenBuilder(givenDriver);
                    When = new AgileNamedUserWhenBuilder(whenDriver);
                    Then = new AgileNamedUserThenBuilder(thenDriver);
                }
            }
            
            #nullable restore
            """
            )
        );
    }

    [Test]
    public void Creates_Drivers_For_Actors_And_Subjunctions()
    {
        var generatedSource = Generate(GenerateAgileNamedUserDslSource, false);

        Console.WriteLine(generatedSource);

        Assert.That
        (
            generatedSource,
            Is.EqualTo
            (
            """
            // <auto-generated/>
            
            using System;
            using FluentNetBDD.Dsl;
            using FluentNetBDD.Tests.Dsl.UserFeatures;
            
            
            
            namespace FluentNetBDD.Tests.Generating.Generated;
            
            #nullable enable
            
            public interface IAgileNamedUserGivenUserDriver : IUserWithName, IUserWithAgility {}
            public interface IAgileNamedUserGivenDriver
            {
                IAgileNamedUserGivenUserDriver User { get; }
            }
            
            public interface IAgileNamedUserWhenUserDriver : IUserGreetingAction, IUserAgilityActions {}
            public interface IAgileNamedUserWhenDriver
            {
                IAgileNamedUserWhenUserDriver User { get; }
            }
            
            public interface IAgileNamedUserThenUserDriver : IUserGreetingVerification, IUserAgilityVerification {}
            public interface IAgileNamedUserThenDriver
            {
                IAgileNamedUserThenUserDriver User { get; }
            }
            
            
            
            public partial class AgileNamedUserDsl : Dsl<IAgileNamedUserGivenDriver, IAgileNamedUserWhenDriver, IAgileNamedUserThenDriver>
            {
                public AgileNamedUserDsl(IServiceProvider provider) : base(provider)
                {
                }
            }
            
            #nullable restore
            """
            )
        );
    }

    private static string Generate(string source, bool enableBuilder)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);

        var references = AppDomain.CurrentDomain.GetAssemblies()
            .Where(a => !a.IsDynamic && !string.IsNullOrWhiteSpace(a.Location))
            .Select(a => MetadataReference.CreateFromFile(a.Location))
            .ToList();

        var attributeAssemblyPath = typeof(GenerateDslAttribute).Assembly.Location;
        references.Add(MetadataReference.CreateFromFile(attributeAssemblyPath));

        var compilation = CSharpCompilation.Create(
            "TestAssembly",
            [syntaxTree],
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
        );

        var generator = new DslGenerator(enableBuilder);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator)
            .RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        var generatedTrees = outputCompilation.SyntaxTrees.ToList();
        var dslSyntaxTree = generatedTrees.Last();
        var generatedSource = dslSyntaxTree.ToString();
        return generatedSource;
    }
}
